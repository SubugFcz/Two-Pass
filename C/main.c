/*
Labeling Connected Objects in Hubble-Webb Images

Created by: Ignatius Djaynurdin
Date: 03/05/2023

This program takes in one 32x32 binary difference image
generated by computing the difference of a pair of corresponding tiles in
two larger images.

It replaces black pixels in the Diff array with labels in the range 1-32,
assigning a unique label to each connected component of adjacent pixels
(adjacency is defined by 8-connectivity: in N, NE, E, SE, S, SW, W, NW
directions).

White pixels remain unchanged.
*/

#include <stdio.h>
#include <stdlib.h>

int Load_Mem(char *, int *);

int main(int argc, char *argv[])
{
    int Diff[1024];
    int Num;

    int new_array[1122] = {0};
    int j = 35;
    int new_array2[1122] = {0};
    int q = 1;

    Num = Load_Mem(argv[1], Diff);
    if (Num != 1024)
    {
        printf("value file must contain 1024 entries\n");
        exit(1);
    }
    // Flip the white and black.
    for (int i = 0; i < 1024; i++)
    {
        if (Diff[i] == 16777215)
        {
            Diff[i] = 0;
        }
        else
        {
            Diff[i] = 16777215;
        }
    }
    // Asign new array to create array with background in right, top, and left.
    for (int i = 34; i <= 1088; i += 34)
    {
        for (int k = 0; k < 32; k++)
        {
            int l = i + k + 1;
            new_array[l] = Diff[l - j];
        }
        j = j + 2;
    }
    // Assign the label to each not background
    for (int i = 35; i < 1122; i++)
    {
        if (new_array[i] != 0)
        {
            // Get the surroundings
            int A = new_array2[i - 35];
            int B = new_array2[i - 34];
            int C = new_array2[i - 33];
            int D = new_array2[i - 1];
            // If all of them is 0, create new label and assign it
            if ((A + B + C + D) == 0)
            {
                new_array2[i] = q;
                q++;
            }
            // Get the lowest label
            else
            {
                int minimum = 1122;
                if (A != 0)
                {
                    minimum = A; // Assume a is the minimum value
                }
                if (B < minimum && B != 0)
                {
                    minimum = B;
                }
                if (C < minimum && C != 0)
                {
                    minimum = C;
                }
                if (D < minimum && D != 0)
                {
                    minimum = D;
                }
                new_array2[i] = minimum;
            }
        }
    }

    for (int i = 0; i < 1122; i++)
    {
        if (new_array2[i] == 0)
        {
            printf("  ");
        }
        else
        {
            printf("%2d", new_array2[i]);
        }
        if ((i + 1) % 34 == 0)
        {
            printf("\n");
        }
        else
        {
            printf(" ");
        }
    }
    // Main algorithm.
    for (int i = 32; i >= 1; i--)
    {
        int smallest = i; // Smallest that touches i
        for (int pix = 35; pix < 1122; pix++)
        {
            if (new_array2[pix] == i)
            {
                int F = new_array2[pix + 1];
                int G = new_array2[pix + 33];
                int H = new_array2[pix + 34];
                int I = new_array2[pix + 35];
                if (F != 0 && (F < smallest))
                {
                    smallest = F;
                }
                if (G != 0 && (G < smallest))
                {
                    smallest = G;
                }
                if (H != 0 && (H < smallest))
                {
                    smallest = H;
                }
                if (I != 0 && (I < smallest))
                {
                    smallest = I;
                }
            }
        }
        for (int pix2 = 35; pix2 < 1122; pix2++)
        {
            if (new_array2[pix2] == i)
            {
                new_array2[pix2] = smallest;
            }
        }
    }

    printf("\n");
    printf("\n");

    for (int i = 0; i < 1122; i++)
    {
        if (new_array2[i] == 0)
        {
            printf("  ");
        }
        else
        {
            printf("%2d", new_array2[i]);
        }
        if ((i + 1) % 34 == 0)
        {
            printf("\n");
        }
        else
        {
            printf(" ");
        }
    }

    return 0;
}

int Load_Mem(char *InputFileName, int Diff[])
{
    int N, Addr, Value, NumVals;
    FILE *FP;

    FP = fopen(InputFileName, "r");
    if (FP == NULL)
    {
        printf("%s could not be opened; check the filename\n", InputFileName);
        return 0;
    }
    else
    {
        for (N = 0; N < 1024; N++)
        {
            NumVals = fscanf(FP, "%d: %d", &Addr, &Value);
            if (NumVals == 2)
                Diff[N] = Value;
            else
                break;
        }
        fclose(FP);
        return N;
    }
}