# =================================================================
#
#	 Labeling Connected Objects in Hubble-Webb Images
#
# Shell code by: GT ECE 2035 
# Created by: Ignatius Djaynurdin
# Date: 03/05/2023
# 
# ECE 2035 Project1-2
#
# This program takes in one 32x32 binary difference image (generated by swi 602
# by computing the difference of a pair of corresponding tiles in	
# two larger images and placed into memory at Diff).
# It replaces black pixels in the Diff array with labels in the range 1-32,
# assigning a unique label to each connected component of adjacent pixels
# (adjacency is defined by 8-connectivity: in N, NE, E, SE, S, SW, W, NW 
# directions).
# White pixels remain unchanged.
#
# The program reports the results with swi 604:
#     $1 Base addr of labeled array
#     $4 num components, $5 min size, $6 max size 
# Oracle:
#     $2 number labeling errors
#     $7 correct num components, $8 correct min size, $9 correct max size
# Labeling errors:
#     black pixel not labeled,
#     white pixel not white,
#     labels out of range [1-32] inclusive
#     labels in memory are not consistent with correct CC labeling.
# ===========================================================================

.data
Diff:        	.alloc	1024			# allocate binary threshold image space
.text
CC:		addi	$1, $0, Diff			# set memory base
		addi    $2, $0, 116				# TileNum to start with
		swi		602						# create and display images
	
	######################################################################

Count:	.alloc 32				        # count table
Equi:	.alloc 32				        # Equi table
        addi    $15, $1, -128
        sw		$31, -132($1)			# Save $31
        addi 	$7, $0, 4 				# Create new counter for the loop1
        addi    $8, $0, 1
		addi	$3, $0, 128				# Value 128
		addi	$2, $0, 124			    # Value 124
        addi	$5, $0, -132            # Address for EQ
       
popul:  slt     $6, $15, $1
        beq     $6, $0, FirstE

        add     $25, $5, $15
        sw      $8, 0($15)
        sw      $0, 0($25)

        addi    $15, $15, 4
        addi    $8, $8, 1
        j       popul

FirstE: addi    $8, $0, 1               # Counter Q

First:	lw		$25, Diff($0)			# Value for index 0	
		bne		$25, $0, Top			# If first ever is background, jump to Top
		sw		$8, 0($1)				# Label it as 1
		addi 	$8, $8, 1 				# Increment Label Q

Top:	slti	$24, $7, 125 			# LoopT command
		beq		$24, $0, Bloop 		    # Base case exit the loop

		lw		$25, Diff($7)			# Value for index n
		bne		$25, $0, Inc1			# If n is background, jump to Inc1

		addi 	$11, $7, -4				# Index for n-4
		lw		$11, Diff($11)			# Value for n-4

		slti	$24, $11, 33			# If n-4 is less than 33, $24 will be 1
		bne		$24, $0 ,Old1			# if $24 is 1, jump to Old Label

		sw		$8, Diff($7)			# Label it as Q if it is black
		addi 	$8, $8, 1 				# Increment Label Q
		j		Inc1

Old1:	sw		$11,Diff($7)			# Label it with previous label if it is black

Inc1:	addi 	$7, $7, 4 				# Loop increment just like i++ in java for loop
		j 		Top 					# Jump to caller		

Bloop:	slti	$24, $7, 4093 			# LoopT command
		beq		$24, $0, twpase 		# Base case exit the loop

		lw		$25, Diff($7)			# Value for index n
		bne		$25, $0, IncB			# If n is background, jump to IncB

		addi 	$11, $7, -132			# Index for n-132
		lw		$11, Diff($11)			# Value for n-132		

		addi 	$12, $7, -128			# Index for n-128
		lw		$12, Diff($12)			# Value for n-128

		addi 	$13, $7, -124			# Index for n-124
		lw		$13, Diff($13)			# Value for n-124

		addi 	$14, $7, -4				# Index for n-4
		lw		$14, Diff($14)			# Value for n-4

Left:	div		$7, $3					# Left Edges?
		mfhi	$15
		bne		$15, $0, Right			# If not, move to Right

        slti	$21, $12, 33			# If background, move ahead
		bne		$21, $0, safe		    # Go to lal if $12 is background
        slti	$21, $13, 33			# If background, move ahead
		bne		$21, $0, safe

        j       NLabel

safe:	slt 	$24, $13, $12
    	beq 	$24, $0, ol1

		sw		$13,Diff($7)			
		j		IncB

ol1:	sw		$12,Diff($7)			
		j		IncB

Right:	div		$7, $3					# Right Edges?
		mfhi	$15
		bne		$15, $2, low			# If not, move to common

        slti	$21, $12, 33			# If background, move ahead
        bne		$21, $0, safe2		    # Go to lal if $12 is background
		slti	$21, $14, 33			# If background, move ahead
        bne		$21, $0, safe2	        # Go to lal if $12 is background
        slti	$21, $11, 33			# If background, move ahead
		bne		$21, $0, safe2

        j       NLabel

safe2:	slt		$24, $11,$12			# Check lower value
		beq		$24, $0, sw1

Chk2:	slt		$24, $11,$14
		beq		$24, $0, sw2
		
        sw		$11,Diff($7)			
		j		IncB

sw1:    slt		$24, $12 ,$14
		beq		$24, $0, sw2

        sw		$12,Diff($7)			
		j		IncB

sw2:    sw		$14,Diff($7)			
		j		IncB

low:	slt 	$24, $14, $13			# Store smallest value in $11
    	beq 	$24, $0, skis1
		add 	$24, $13, $0			# Switch if 14 is smaller than 13
    	add 	$13, $14, $0
    	add 	$14, $24, $0
skis1: 	slt 	$24, $13, $12
    	beq 	$24, $0, skis2
    	add 	$24, $12, $0			# Switch if 13 is smaller than 12
    	add 	$12, $13, $0
    	add 	$13, $24, $0
skis2: 	slt 	$24, $12, $11
    	beq 	$24, $0, cche
    	add 	$24, $11, $0			# Switch if 12 is smaller than 11
   		add 	$11, $12, $0
    	add 	$12, $24, $0			# Smallest value is in $11
cche:	slti	$24, $11, 33			# Check if the smallest value is actually nonsense, set register 11 to 0.
		bne		$24, $0, ex
		sw		$8,Diff($7)				# Label it as Q if it is black
		addi 	$8, $8, 1 				# Increment Label Q
        j       IncB
ex:		sw		$11,Diff($7)			# Label it with previous label 
        j       checa

checa:  bne     $11, $12, chec
        bne     $12, $13, chec
        bne     $13, $14, chec
        j       IncB

chec:	sll     $24, $11, 2
        add     $15, $5, $24
        lw		$19, Diff($15)			# Save the value of n-132

        slti	$24, $12, 33			# Check if the value is actually nonsense, set register to 0.
		beq		$24, $0, ex1
        sll     $24, $12, 2
        add     $15, $5, $24
        lw		$6, Diff($15)			# Save the value of n-128
        j       ab
ex1:    add     $6, $0, $19

ab:     slti	$24, $13, 33			# Check if the value is actually nonsense, set register to 0.
		beq		$24, $0, ex2
        sll     $24, $13, 2
        add     $15, $5, $24
        lw		$21, Diff($15)			# Save the value of n-124
        j       ac
ex2:    add     $21, $0, $19
        
ac:     slti	$24, $14, 33			# Check if the value is actually nonsense, set register to 0.
		beq		$24, $0, ex3
        sll     $24, $14, 2
        add     $15, $5, $24
        lw		$22, Diff($15)			# Save the value of n-4
        j       strt
ex3:    add     $22, $0, $19

strt:   slt 	$24, $22, $21			# Store smallest value in $19
    	beq 	$24, $0, skis11
		add 	$24, $21, $0			# Switch if 14 is smaller than 13
    	add 	$21, $22, $0
    	add 	$22, $24, $0
skis11: slt 	$24, $21, $6
    	beq 	$24, $0, skis21
    	add 	$24, $6, $0			# Switch if 13 is smaller than 12
    	add 	$6, $21, $0
    	add 	$21, $24, $0
skis21: slt 	$24, $6, $19
    	beq 	$24, $0, kli
    	add 	$24, $19, $0			# Switch if 12 is smaller than 11
   		add 	$19, $6, $0
    	add 	$6, $24, $0			# Smallest value is in $11
kli:    beq     $19, $6, sp1
        add     $15, $0, $6
        jal     iter
sp1:    beq     $19, $21, sp2
        add     $15, $0, $21
        jal     iter
sp2:    beq     $19, $22, kkk
        add     $15, $0, $22
        jal     iter
kkk:    j 		IncB

NLabel:	sw		$8,Diff($7)				# Label it as Q if it is black
		addi 	$8, $8, 1 				# Increment Label Q

IncB:	addi 	$7, $7, 4 				# Loop increment just like i++ in java for loop
		j 		Bloop 					# Jump to caller

iter:	addi    $27, $1, -128

itera:	slt	    $24, $27, $1 			# Loop command
		beq		$24, $0, itere 			# Base case exit the loop
        sub     $24, $27, $1

        lw		$4, Diff($24)			
        bne     $4, $15, inca
        sw		$19, Diff($24)

inca:	addi	$27, $27, 4
		j		itera
itere:	jr		$31

twpase: addi    $7, $0, 0
        addi    $19, $0, -264

twpass: slti	$24, $7, 4093 		    # Loop command
		beq		$24, $0, contie 		# Base case exit the loop

        lw      $8, Diff($7)            # Label

        slti	$24, $8, 33			    # If background, move ahead
		beq		$24, $0, IncC
        
        sll     $8, $8, 2
        add     $15, $5, $8
        lw		$6, Diff($15)			
        sw      $6, Diff($7)

        sll     $6, $6, 2
        add     $21, $19, $6
        lw		$11, Diff($21)			
        addi    $11, $11, 1
        sw      $11, Diff($21)

IncC:	addi 	$7, $7, 4 				# Loop increment just like i++ in java for loop
		j 		twpass 					# Jump to caller

contie: addi    $15, $0, 4
        addi    $4, $0, 32
        addi    $5, $0, 1024
        addi    $6, $0, 0

conti:  slti    $7, $15, 129
        beq     $7, $0, End

        addi    $7, $15, -264
        lw		$11, Diff($7)
        bne     $11, $0, sd
        addi    $4, $4, -1
        j       sma

sd:     slt     $2, $11, $5
        beq     $2, $0, smp	
        addi    $5, $11, 0

smp:    slt     $2, $6, $11
        beq     $2, $0, sma	
        addi    $6, $11, 0

sma:    addi 	$15, $15, 4
        j       conti

End:	lw		$31, -132($1)			# Return the value for $31
        beq     $4, $0, mod
        j       Report

mod:    addi    $5, $0, 0  

	######################################################################

Report:	addi    $1, $0, Diff
		swi     604						# Report results
		jr      $31
